- whenever there are changes made in .env, manually restart the server, nodemon doesn't work.

process.env.PORT
--> access env variables in nodejs for configuring port on which a server should listen
why? --> deployment flexibilty --> config mgmnt
-->When developing web apps, best to configure the server to listen on a port defined by an env variable. This allows flexibility, avoids hardcoding the port number.

can also store process.env.PORT in any variable and use
--------------------------------------------------------------------------------------------------------------------------
replacement of this written in index.js page, mongodb connection point.

APPROACH 1: using try catch for error handling and using async await...
import express from "express";
const app = express();
(async () => {
  try {
    await mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`);
    app.on("error", (error) => {
        console.log("ERRR: ", error)
        throw error
    })

    app.listen(process.env.PORT, () => {
        console.log(`App is listening on port ${process.env.PORT}`);
    })

  } catch (error) {
    console.log("Error: ", error);
    throw err;
  }
})();

--------------------------------------------------------------------------------------------------------------------------


request can be used to extract plenty of info.
req.params ---> url data extraction
req.body ---> data in forms, json etc..
data can be accessed through even cookies.
when using cookie-parser middleware, this prop is an obj containing cookies sent by req.
cookie-parser need to be installed through npm package --> npm i cookie-parser ---> require('cookie-parser') / import

CORS package ---> enable to make settings [cross-origin-resource-sharing] ---> npm i cors --> require/import
app.use(cors()) --> origin, credentials etc..
for middleware / config settings ----> app.use() ***

---------------------------------/* important configurations of express */ -----------------------------------------------
app.use(express.json({
    limit: "16kb" ---> server power
})) --> configuring json and accepting
app.use(express.urlencoded({ extended: true, limit: "16kb" }));
extended:true ---> nesting enabled in objects
app.use(express.static("public")); ---> to store files and folders in [public], which is accessible to anyone. [public]

app.use(cookie-parser())
cookie-parser imported ---> so that through we can access cookies and set cookies in user's browser 
--------------------------------------------------------------------------------------------------------------------------
middleware ---> functionality between req and res cycle.
res returns only if middleware execution is successfull else req is reverted.
for example: /instagram -----> middleware ------> res.send("sathwik")
the middleware can check things like ----> if user is logged in / check if user is admin 
middleware can be more than one... order of middleware declaration decides their order of execution
middleware has 3 params ---> (req, res, next)
"next" ---> used to execute the next middleware if written else discard.

statusCode --> info responses (100 - 199)
--> successfull response ( 200 - 299)
--> redirection response ( 300 - 399 )
--> client error response (400 - 499)
--> Server error response (500 - 599)
----------------------------------------------------------------------------------------------------------------------
Promise.resolve(requestHandler(req, res, next)).catch((err) => next(err));
--> this line.. is used to ensure that result of reqhandler is treated as promise. this req handler can be an async function that returns a promise or sync function 
--> if reqhandler throws an error/returns rejected promise, error is passed to next function.

Error.captureStackTrace(this, this.constructor);
--> error.captureStackTrace is method available in V8 engine, allows u to capture stack trace at a specific point and customize stack trace.
-->
----------------------------------------------------------------------------------------------------------------------
(optimal way)in Mongodb, if any field should be made searchable ---> make index: true;
but donot use index in every field, use it wisely

(npm package)mongoose-aggregate-paginate-v2 --> allows to write aggregation queries.

mongoose allows to write your own plug-ins using schemaName.plugin()
----------------------------------------------------------------------------------------------------------------------
bcrypt -->library made on core nodejs packages --> helps you to hash your password
bcyrpjs --> optimized in plain JS with 0 dependencies, compatible with bcrypt 

JWT - Json web token --> tokens are made which are not human readable using cryptic algorithm
three parts --> headers(algo and token type), payload(data), verify signature
example: header
{
    "alg": "HS256",
    "typ": "JWT"
}
above header is turned into ---> eyHnHSDJNnsnfhjjsnHSDFHNjbdfXCVJ9
example: payload (data)
{
    "name": "sai",
    "iat": 1516239022
}
above data is encrypted as eyJzdWIi0iTxMjM0NTY3ODKwiJIhiwINNKNSF39hHJFJ82IYFQ
example: verify signature
HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    your-256-bit-secret
) secret base64 encoded
above "secret" is the one that makes every token unique, else anyone could decode the algo. [secret=protection]

How to encrypt now?
import jwt and bcrypt
direct encryption not possible, so take help of hooks of mongoose
"pre hook" --> middleware, run just before saving the data, so select "save" in userSchema.pre("save")
userSchema.pre("event", callback function);
callback function should have param next, coz its a middleware.
"next()" should be called to pass on to the next middleware.
----------------------------------------------------------------------------------------------------------------------
ENCRYPTING the PASSWORD (check "user.model.js" file for code)
issue:
userSchema.pre("save", async function (next) {
  this.password = bcrypt.hash(this.password, 10);
  next();
});
whenever the data is saved, the password also keeps on saving/changing, problem is entire password field's access is there with encrypt function, so it keeps on running the encrypt function.
solution:
So, make sure, you set the functionality such that encryption function runs only when password field is modified directly by user.
include --> if (!this.isModified("password")) return next();
this means that if password is not modified then go on with next()
else if its modified --> then go on with bcrypt.hash and then next()
---> check user.model.js
----------------------------------------------------------------------------------------------------------------------
methods can be created in mongoose

password comparison using "bcrypt" [true/false]
adding property "isPasswordCorrect"
userSchema.methods.isPasswordCorrect = async func(pass) {
    return await bcrypt.compare(pass, this.pass)
}
using await because takes time.
pass --> string data, this.pass --> encrypted string data
result is true/false format
----------------------------------------------------------------------------------------------------------------------
JWT is a bearer token, means its like a key to database.
whoever bears this token, is granted the access of database.
jwt tokens --> private key, expiry duration

access token expiry less than refresh token expiry
access token will not be stored in database but refresh token will be stored in database

refreshToken has less information due to frequent refreshes

jwt.sign() used to synchronously convert given payload to Json webtoken payload.

writing accesstokengenerator using jwt.sign()
writing refreshtokengenerator using jwt.sign()
----------------------------------------------------------------------------------------------------------------------
file handling --> backend engineer's work.
file upload --> seperate utility function, resusable

user upload file using multer and keep in local server
use cloudinary pick file from local storage and then put it on server.
if file uploaded, remove it from server.

code in cloudinary.js --> reusable --> save it

fs --> file system in nodejs--> read, write, remove and all other operations on file [Async/sync]
fsPromises.unlink(path) --> if path refers to symbolic link, then link is removed without affecting file or dir its refering to. removing the link referred by path, without impacting the rest of the file/directory.
path... string or buffer or url
returns... promise (undefined if success)

cloudinary details in ".env" file
store cloud name, api key , api secret in .env file and get them using process.env.cloudname/apikey/apisecret.
to upload file on cloudinary --> cloudinary.uploader.upload(filepath, { ... any fields in key:value format } )

creating middleware using multer
import multer from "multer";
const upload = multer({ dest: '/uploads/' })
app.post('/profile', upload.single('avatar'), funcX(req, res, next) {
    //code... single photo
})
here we can use -->  upload.array('photos', 12) for array of photos
 ---> upload.fields( [ { key1:"value1", key2:"value2" } ] )
 so the funcn between '/path' and handlerfunc funcX is middleware....

check out multer.middleware.js file for **
-----------------------------------------------------------------------------------------------------------------------------

ROUTER AND CONTROLLER WITH DEBUGGING


====> refer app.js and user.routes.js

app.use("/api/v1/users", userRouter) ---> in app.js

router.route("/register").post(userRegister); ---> user.routes.js

in the url localhost:8000/users/......./
....... after /api/v1/users/ the next part of "url" accessed from user.routes.js
localhost:8000/api/v1/users/register ---> /users accessed in app.use in app.js
/users when accessed, sends us to route userRouter that is user.routes.js
now here sub-routes written like /registers, /login which in-turn refer controller methods for further interaction.
example: router.route("/register").post(registerUser);
registerUser written in controller


when you export like this ---> export { funcName },---> then import it also import { funcName } from "..path" 
when you export like this ---> export default funcName ----> then you can import ---> import "nameofyourchoice" from "path"

-----------------------------------------------------------------------------------------------------------------------------


in user.routes.js

  upload.fields([
    {
      name: "avatar",
      maxCount: 1,
    },
    {
      name: "coverImage",
      maxCount: 1,
    },
  ]),

upload.fields ----> method provided by multer that allows handling multiple file fields. takes an array of objects.
name:avatar, maxCount:1 ---> this config tells the middleware to handle file name field "avatar" and allows max 1 file for this field.
same goes with coverImage config.


VALIDATING GIVEN USERNAME AND EMAIL :

at user.controller.js
check each field of array and trim the whitespaces and even after trimming the whitespaces if field is empty then error.
some checks if at least one element passes the provided test
trim removes whitespaces from both ends of string.
if (
  [fullName, email, username, password].some((field) => field?.trim() === "")
) {
  throw new ApiError(400, "All fields are required");
}

at user.controller.js
.findOne() is a query method provided by ORM library to find a single docx in DB that matches specified criteria.
$or -- logical OR operation.
checking if given criteria is found in db, if its found then throw an error.

at user.controller.js
const avatarLocalPath = req.files?.avatar[0]?.path;
req.files ---> access the files uploaded through multer
req.files? ---> if the req does not have files property, expression doesnot throw error, instead evaluates it to undefined.
req.files?.avatar ---> if req.files doesnt exist or null or undefined, accessing avatar doesnot throw error, but evaluates to undefined.
req.files?.avatar[0] ---> if req.files?.avatar exists access the first element [0], else evaluate to undefined.
req.files?.avatar[0]?.path ---> if req.files?.avatar[0] exists, it attempts to access path, if all properties in chain exists then path will be assigned, else null or undefined is assigned.

same goes with const coverImageLocalPath = req.files?.coverImage[0]?.path;

chaining optional operator : "?."
object?.property ---> if object exists, then access the property given

Mongodb assigns "_id" with every entry.


finding user by _id, if found then remove his password and refreshToken.

const createdUser = await User.findById(user._id).select(
  "-password -refreshToken"
)
.select() ---> specifies which doc fields to be included and excluded. "-" for excluded
remove password and refersh token after user found in database